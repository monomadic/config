#!/bin/zsh

# Video File Analyzer and Renamer
# Dependencies: ffprobe (part of ffmpeg)

set -o errexit -o pipefail

DRY_RUN=false
USE_COLOR=false

# NerdFonts icons
ICON_VIDEO="󰎈"
ICON_OK=""
ICON_WARN=""

# Color handling (disabled by default)
RESET=""; GREEN=""; YELLOW=""; CYAN=""

enable_color() {
  RESET=$'\e[0m'
  GREEN=$'\e[32m'
  YELLOW=$'\e[33m'
  CYAN=$'\e[36m'
  USE_COLOR=true
}

# Parse options
while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run) DRY_RUN=true; shift ;;
    --color) enable_color; shift ;;
    -h|--help)
      print -r -- "Usage: $0 [OPTIONS] video_file..."
      print -r -- "Options:"
      print -r -- "  --dry-run    Show what would be done without renaming"
      print -r -- "  --color      Enable ANSI colors in output"
      print -r -- "  -h, --help   Show this message"
      exit 0
      ;;
    -*)
      print -r -- "${YELLOW}${ICON_WARN} Unknown option: $1${RESET}"
      exit 1
      ;;
    *) break ;;
  esac
done

# Ensure ffprobe exists
if ! command -v ffprobe &>/dev/null; then
  print -r -- "${YELLOW}${ICON_WARN} ffprobe is required but not installed.${RESET}"
  exit 1
fi

# Strip ALL {...} blocks and known #tags
clean_name() {
  local name="$1"
  # remove every {...} block (non-nested)
  name="$(printf '%s' "$name" | sed -E 's/\{[^}]*\}//g')"
  # remove specific #tags
  local tags=(1080p 1080 720p 4k 60fps 30fps 25fps)
  for t in $tags; do
    name="${name//\#$t/}"
  done
  # remove trailing " s01"
  name="$(printf '%s' "$name" | sed -E 's/[[:space:]]s01$//I')"
  # collapse & trim spaces
  name="${name//  / }"; name="${name//  / }"   # twice to be safe
  name="${name## }"; name="${name%% }"
  print -r -- "$name"
}

# Extract a 5-char rating like ★★★☆☆ from anywhere in the name
# Prints: "<name_without_rating>\n<rating_or_empty>"
extract_rating() {
  local s="$1"
  local rating=""
  # first match only
  rating="$(printf '%s' "$s" | perl -CSDA -ne 'if(/([★☆]{5})/){print $1; exit 0}')"
  # remove ALL occurrences (just in case)
  s="$(printf '%s' "$s" | perl -CSDA -pe 's/[★☆]{5}//g')"
  # collapse & trim
  s="${s//  / }"; s="${s//  / }"
  s="${s## }"; s="${s%% }"
  print -r -- "$s"
  print -r -- "$rating"
}

# Map smaller dimension to a resolution label
get_resolution_label() {
  local d=${1:-0}
  if   (( d <= 480  )); then print -r -- "480p"
  elif (( d <= 720  )); then print -r -- "720p"
  elif (( d <= 1080 )); then print -r -- "1080p"
  elif (( d <= 1440 )); then print -r -- "1440p"
  elif (( d <= 2160 )); then print -r -- "2160p"
  else                      print -r -- "${d}p"
  fi
}

# Format duration in human readable form (rounded to largest unit)
format_duration() {
  local secs=${1:-0}
  local hours=$(( secs / 3600 ))
  local mins=$(( secs / 60 ))
  
  if (( hours > 0 )); then
    print -r -- "${hours}hr"
  elif (( mins > 0 )); then
    print -r -- "${mins}min"
  else
    print -r -- "${secs}sec"
  fi
}

# Extract rotation from multiple possible locations
get_rotation() {
  local file="$1"
  local rotation=""
  
  # Try stream_side_data (display matrix) - most reliable for MOV/MP4
  rotation=$(ffprobe -v error -select_streams v:0 \
      -show_entries stream_side_data=rotation \
      -of default=noprint_wrappers=1:nokey=1 -- "$file" 2>/dev/null | head -1)
  
  # If not found, try stream tags
  if [[ -z "$rotation" ]]; then
    rotation=$(ffprobe -v error -select_streams v:0 \
        -show_entries stream_tags=rotate \
        -of default=noprint_wrappers=1:nokey=1 -- "$file" 2>/dev/null | head -1)
  fi
  
  # If not found, try format tags
  if [[ -z "$rotation" ]]; then
    rotation=$(ffprobe -v error \
        -show_entries format_tags=rotate \
        -of default=noprint_wrappers=1:nokey=1 -- "$file" 2>/dev/null | head -1)
  fi
  
  # Default to 0 if nothing found
  [[ -z "$rotation" ]] && rotation="0"
  print -r -- "$rotation"
}

process_video() {
  local file="$1"
  local filename="${file:t}"
  local dirname="${file:h}"
  local extension="${filename:e}"
  [[ "${extension:l}" == "m4v" ]] && extension="mp4"
  local name_without_ext="${filename:r}"

  # Pull out rating first (could be anywhere), then clean the remaining name
  local rating extracted_name
  {
    local out; out=("${(@f)$(extract_rating "$name_without_ext")}")
    extracted_name="${out[1]}"
    rating="${out[2]}"
  }
  name_without_ext="$(clean_name "$extracted_name")"

  # Probe for video stream info
  local video_info
  if ! video_info=$(ffprobe -v error -select_streams v:0 \
      -show_entries stream=width,height,r_frame_rate,bit_rate \
      -of csv=p=0:s=, -- "$file" 2>/dev/null); then
    print -r -- "${YELLOW}${ICON_WARN} Could not read video info: $file${RESET}"
    return
  fi

  # Get rotation from multiple sources
  local rotation; rotation="$(get_rotation "$file")"

  # Probe for duration
  local duration_secs
  if ! duration_secs=$(ffprobe -v error -show_entries format=duration \
      -of csv=p=0 -- "$file" 2>/dev/null); then
    duration_secs="0"
  fi
  # Round to nearest integer
  duration_secs=$(awk -v d="$duration_secs" 'BEGIN{printf("%d", d+0.5)}')

  local width height frame_rate bit_rate
  width=$(     print -r -- "$video_info" | cut -d, -f1)
  height=$(    print -r -- "$video_info" | cut -d, -f2)
  frame_rate=$(print -r -- "$video_info" | cut -d, -f3)
  bit_rate=$(  print -r -- "$video_info" | cut -d, -f4)

  # fps -> nearest integer
  if [[ $frame_rate == */* ]]; then
    local num=${frame_rate%%/*}
    local denom=${frame_rate##*/}
    if (( denom > 0 )); then
      frame_rate=$(( (num + denom/2) / denom ))
    else
      frame_rate=0
    fi
  fi

  # Check if rotation swaps dimensions (90 or 270 degrees)
  # Handle negative angles
  local display_width=$width
  local display_height=$height
  local abs_rotation=${rotation#-}  # remove negative sign
  if [[ "$abs_rotation" == "90" || "$abs_rotation" == "270" ]]; then
    display_width=$height
    display_height=$width
  fi

  # Resolution from smaller dimension
  local smaller_dim=$(( display_width < display_height ? display_width : display_height ))
  local resolution; resolution="$(get_resolution_label "$smaller_dim")"

  # Orientation based on display dimensions
  local orientation
  if (( display_width > display_height )); then
    orientation="landscape"
  elif (( display_height > display_width )); then
    orientation="portrait"
  else
    orientation="square"
  fi

  # Mbps rounded to integer
  local mbps="unknown"
  if [[ -n "$bit_rate" && "$bit_rate" != "N/A" ]]; then
    mbps="$(awk -v b="$bit_rate" 'BEGIN{printf("%dmbps", (b+500000)/1000000)}')"
  fi

  # Format duration
  local duration; duration="$(format_duration "$duration_secs")"

  local rating_suffix=""
  [[ -n "$rating" ]] && rating_suffix=" ${rating}"

  local new_filename="${name_without_ext} {${resolution} ${frame_rate}fps ${duration} ${mbps} ${orientation}}${rating_suffix}.${extension}"
  local new_path="${dirname}/${new_filename}"

  if [[ -e "$new_path" ]]; then
    print -r -- "${YELLOW}${ICON_WARN} Exists: $new_filename${RESET}"
  else
    if $DRY_RUN; then
      print -r -- "${CYAN}${ICON_VIDEO} ${new_filename}${RESET}"
    else
      mv -- "$file" "$new_path"
      print -r -- "${GREEN}${ICON_OK} ${new_filename}${RESET}"
    fi
  fi
}

# Process args
for file in "$@"; do
  if [[ -f "$file" ]]; then
    case "${file:l}" in
      *.mp4|*.mov|*.avi|*.mkv|*.wmv|*.flv|*.webm|*.m4v) process_video "$file" ;;
    esac
  fi
done
