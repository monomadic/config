#!/bin/zsh

# Video File Analyzer and Renamer
# Dependencies: ffprobe (part of ffmpeg)

set -o errexit -o pipefail

DRY_RUN=false

# NerdFonts icons
ICON_VIDEO="󰎈"
ICON_OK=""
ICON_WARN=""

# Colors
RESET=$'\e[0m'
GREEN=$'\e[32m'
YELLOW=$'\e[33m'
CYAN=$'\e[36m'

# Parse options
while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run) DRY_RUN=true; shift ;;
    -h|--help)
      print -r -- "Usage: $0 [OPTIONS] video_file..."
      print -r -- "Options:"
      print -r -- "  --dry-run    Show what would be done without renaming"
      print -r -- "  -h, --help   Show this message"
      exit 0
      ;;
    -*)
      print -r -- "${YELLOW}${ICON_WARN} Unknown option: $1${RESET}"
      exit 1
      ;;
    *) break ;;
  esac
done

# Ensure ffprobe exists
if ! command -v ffprobe &>/dev/null; then
  print -r -- "${YELLOW}${ICON_WARN} ffprobe is required but not installed.${RESET}"
  exit 1
fi

# Strip ALL {...} blocks and known #tags
clean_name() {
  local name="$1"
  # remove every {...} block (non-nested)
  name="$(printf '%s' "$name" | sed -E 's/\{[^}]*\}//g')"
  # remove specific #tags
  local tags=(1080p 1080 720p 4k 60fps 30fps 25fps)
  for t in $tags; do
    name="${name//\#$t/}"
  done
  # collapse & trim spaces
  name="${name//  / }"; name="${name//  / }"   # twice to be safe
  name="${name## }"; name="${name%% }"
  print -r -- "$name"
}

# Map smaller dimension to a resolution label
get_resolution_label() {
  local d=${1:-0}
  if   (( d <= 480  )); then print -r -- "480p"
  elif (( d <= 720  )); then print -r -- "720p"
  elif (( d <= 1080 )); then print -r -- "1080p"
  elif (( d <= 1440 )); then print -r -- "1440p"
  elif (( d <= 2160 )); then print -r -- "2160p"
  else                      print -r -- "${d}p"
  fi
}

process_video() {
  local file="$1"
  local filename="${file:t}"
  local dirname="${file:h}"
  local extension="${filename:e}"
  local name_without_ext="${filename:r}"

  name_without_ext="$(clean_name "$name_without_ext")"

  # Probe
  local video_info
  if ! video_info=$(ffprobe -v error -select_streams v:0 \
      -show_entries stream=width,height,r_frame_rate,bit_rate \
      -of csv=p=0:s=, -- "$file" 2>/dev/null); then
    print -r -- "${YELLOW}${ICON_WARN} Could not read video info: $file${RESET}"
    return
  fi

  local width height frame_rate bit_rate
  width=$(   print -r -- "$video_info" | cut -d, -f1)
  height=$(  print -r -- "$video_info" | cut -d, -f2)
  frame_rate=$(print -r -- "$video_info" | cut -d, -f3)
  bit_rate=$( print -r -- "$video_info" | cut -d, -f4)

  # fps -> nearest integer (keeps existing ints)
  if [[ $frame_rate == */* ]]; then
    local num=${frame_rate%%/*}
    local denom=${frame_rate##*/}
    if (( denom > 0 )); then
      frame_rate=$(( (num + denom/2) / denom ))
    else
      frame_rate=0
    fi
  fi

  # Resolution from smaller dimension (handles portrait)
  local smaller_dim=$(( width < height ? width : height ))
  local resolution; resolution="$(get_resolution_label "$smaller_dim")"

  # Mbps (no bc dependency)
  local mbps="unknown"
  if [[ -n "$bit_rate" && "$bit_rate" != "N/A" ]]; then
    mbps="$(awk -v b="$bit_rate" 'BEGIN{printf("%.1fmbps", b/1000000)}')"
  fi

  local new_filename="${name_without_ext} {${resolution}@${frame_rate}fps, ${mbps}}.${extension}"
  local new_path="${dirname}/${new_filename}"

  if [[ -e "$new_path" ]]; then
    print -r -- "${YELLOW}${ICON_WARN} Exists: $new_filename${RESET}"
  else
    if $DRY_RUN; then
      print -r -- "${CYAN}${ICON_VIDEO} ${new_filename}${RESET}"
    else
      mv -- "$file" "$new_path"
      print -r -- "${GREEN}${ICON_OK} ${new_filename}${RESET}"
    fi
  fi
}

# Process args
for file in "$@"; do
  if [[ -f "$file" ]]; then
    case "${file:l}" in
      *.mp4|*.mov|*.avi|*.mkv|*.wmv|*.flv|*.webm|*.m4v) process_video "$file" ;;
    esac
  fi
done
