#!/usr/bin/env zsh
autoload -U colors && colors
set -euo pipefail
emulate -L zsh
setopt no_nomatch

print_only=0
out="results.json"

while [[ $# -gt 0 ]]; do
  case "$1" in
    -p|--print-only) print_only=1; shift ;;
    -o) out="${2:-results.json}"; shift 2 ;;
    --) shift; break ;;
    -*) print -u2 -- "Unknown option: $1"; exit 2 ;;
    *) break ;;
  esac
done

if (( $# < 2 )); then
  print -u2 "Usage: $0 [-p|--print-only] [-o results.json] DIR1 DIR2 [DIR...]"
  exit 2
fi

# jq/jaq detection
if command -v jaq >/dev/null 2>&1; then
  JQ=(jaq)
elif command -v jq >/dev/null 2>&1; then
  JQ=(jq)
else
  print -u2 "Need jq or jaq"
  exit 1
fi

if ! command -v czkawka_cli >/dev/null 2>&1; then
  print -u2 "Need czkawka_cli"
  exit 1
fi

dirs=("$@")
dargs=()
for d in "${dirs[@]}"; do
  dargs+=(-d "$d")
done

czkawka_cli dup \
  "${dargs[@]}" \
  -s size \
  --dry-run \
  --compact-file-to-save "$out"

renames_json="$("$JQ" -c '
  to_entries[]
  | .value as $files
  | select(($files|length) > 1)
  | ($files | map(.path)) as $paths
  | { paths: $paths }
' "$out")"

apply_all=0

while IFS= read -r line; do
  [[ -z "$line" ]] && continue
  paths=("${(@f)$(print -r -- "$line" | "$JQ" -r '.paths[]')}")

  print "\n${fg_bold[blue]}Duplicate group:${reset_color}"
  for idx in {1..${#paths[@]}}; do
    print "  ${fg_bold[cyan]}$idx${reset_color}) ${paths[$idx]}"
  done

  if (( ! apply_all )); then
    print -n "${fg_bold[yellow]}Choose canonical file${reset_color} number [1-${#paths[@]}], or (a)ll use this choice: "
    read sel
    case "$sel
