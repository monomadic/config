#!/usr/bin/env zsh
# czk-rename-interactive.zsh
# Usage: czk-rename-interactive.zsh [-p|--print-only] DIR1 DIR2 [DIR...]
# Requires: czkawka_cli, jq or jaq

set -euo pipefail
emulate -L zsh
setopt no_nomatch
autoload -U colors && colors

print_only=0
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p|--print-only) print_only=1; shift ;;
    --) shift; break ;;
    -*) print -u2 -- "Unknown option: $1"; exit 2 ;;
    *) break ;;
  esac
done

if (( $# < 2 )); then
  print -u2 "Usage: $0 [-p|--print-only] DIR1 DIR2 [DIR...]"
  exit 2
fi

# jq/jaq
if command -v jaq >/dev/null 2>&1; then JQ=(jaq)
elif command -v jq  >/dev/null 2>&1; then JQ=(jq)
else print -u2 "Need jq or jaq"; exit 1; fi

command -v czkawka_cli >/dev/null 2>&1 || { print -u2 "Need czkawka_cli"; exit 1; }

# Build -d args
dargs=()
for d in "$@"; do dargs+=(-d "$d"); done

# tmp JSON (auto-removed)
tmpjson="$(mktemp -t czkawka_dups.XXXXXX.json)"
cleanup() { rm -f "$tmpjson" 2>/dev/null || true; }
trap cleanup EXIT

# Run czkawka; silence stdout
czkawka_cli dup "${dargs[@]}" -s size --dry-run --compact-file-to-save "$tmpjson" >/dev/null

# Duplicate groups â†’ NDJSON
groups_json="$("$JQ" -c '
  to_entries[]
  | .value as $files
  | select(($files|length) > 1)
  | { paths: ($files | map(.path)) }
' "$tmpjson" || true)"

[[ -z "$groups_json" ]] && { print "${fg_bold[yellow]}No duplicate groups.${reset_color}"; exit 0; }

# Open TTY so prompts don't read from the JSON stream
if [[ -t 0 ]]; then
  exec {ttyfd}<>/dev/tty
else
  print -u2 "Warning: no TTY; use -p for print-only mode."
  ttyfd=0
fi

while IFS= read -r grp; do
  [[ -z "$grp" ]] && continue
  paths=("${(@f)$(print -r -- "$grp" | "$JQ" -r '.paths[]')}")

  # Build preview of command sets for each possible canonical choice
  # For choice i, every other path p becomes: mv -n -- p  (p:h)/(paths[i]:t)
  print "\n${fg_bold[blue]}Renamed file detected, select correct command:${reset_color}"
  for i in {1..${#paths[@]}}; do
    canon="${paths[$i]}"
    canon_base=${canon:t}
    print "  ${fg_bold[cyan]}$i${reset_color})"
    for p in "${paths[@]}"; do
      [[ "$p" == "$canon" ]] && continue
      new_path="${p:h}/$canon_base"
      # Show exactly what would be executed (human-readable, one per line)
      print "     mv -n -- $p $new_path"
    done
  done

  # Choose canonical index
  local sel_num=""
  while :; do
    print -n "${fg_bold[yellow]}Choose canonical index${reset_color} [1-${#paths[@]}]: " >&$ttyfd
    read -u $ttyfd sel_num
    [[ "$sel_num" == <-> && $sel_num -ge 1 && $sel_num -le ${#paths[@]} ]] && break
  done

  canonical="${paths[$sel_num]}"
  canon_base=${canonical:t}

  # Execute the chosen renames (confirm each)
  for p in "${paths[@]}"; do
    [[ "$p" == "$canonical" ]] && continue
    new_path="${p:h}/$canon_base"
    [[ "$p" == "$new_path" ]] && continue

    # HARD STOP if destination exists (never overwrite/delete)
    if [[ -e "$new_path" ]]; then
      print -u2 "${fg_bold[red]}ERROR:${reset_color} destination exists:"
      print -u2 "  $new_path"
      continue
    fi

    if (( print_only )); then
      # Machine-safe one-liner (quoting)
      printf 'mv -n -- %q %q\n' "$p" "$new_path"
      continue
    fi

    # Pretty, one-per-line prompt
    print "${fg_bold[yellow]}Rename:${reset_color}"
    print "  ${fg[red]}$p${reset_color}"
    print "  ${fg_bold[yellow]}->${reset_color}"
    print "  ${fg[green]}$new_path${reset_color}"
    print -n "[y]es/[n]o: " >&$ttyfd
    read -k 1 -u $ttyfd ans; print
    case "$ans" in
      y|Y) mv -n -- "$p" "$new_path" ;;
      n|N|'') continue ;;
      *)     continue ;;
    esac
  done
done <<< "$groups_json"
