#!/usr/bin/env zsh
# czk-rename-interactive.zsh
# Usage: czk-rename-interactive.zsh [-p|--print-only] DIR1 DIR2 [DIR...]
# Requires: czkawka_cli, jq or jaq

set -euo pipefail
emulate -L zsh
setopt no_nomatch

autoload -U colors && colors

print_only=0
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p|--print-only) print_only=1; shift ;;
    --) shift; break ;;
    -*) print -u2 -- "Unknown option: $1"; exit 2 ;;
    *) break ;;
  esac
done

if (( $# < 2 )); then
  print -u2 "Usage: $0 [-p|--print-only] DIR1 DIR2 [DIR...]"
  exit 2
fi

# jq/jaq
if command -v jaq >/dev/null 2>&1; then JQ=(jaq)
elif command -v jq  >/dev/null 2>&1; then JQ=(jq)
else print -u2 "Need jq or jaq"; exit 1; fi

command -v czkawka_cli >/dev/null 2>&1 || { print -u2 "Need czkawka_cli"; exit 1; }

# Build -d args
dargs=()
for d in "$@"; do dargs+=(-d "$d"); done

# Temp JSON (deleted on exit)
tmpjson="$(mktemp -t czkawka_dups.XXXXXX.json)"
cleanup() { rm -f "$tmpjson" 2>/dev/null || true; }
trap cleanup EXIT

# Run czkawka; silence stdout (keep stderr)
czkawka_cli dup "${dargs[@]}" -s size --dry-run --compact-file-to-save "$tmpjson" >/dev/null

# Extract duplicate groups from compact JSON â†’ stream as ndjson
groups_json="$("$JQ" -c '
  to_entries[]
  | .value as $files
  | select(($files|length) > 1)
  | { paths: ($files | map(.path)) }
' "$tmpjson" || true)"

[[ -z "$groups_json" ]] && { print "${fg_bold[yellow]}No duplicate groups.${reset_color}"; exit 0; }

# Open TTY for interactive prompts (stdin is consumed by the JSON stream otherwise)
if [[ -t 0 ]]; then
  exec {ttyfd}<>/dev/tty
else
  print -u2 "Warning: no TTY; use -p for print-only mode."
  ttyfd=0
fi

# Iterate groups; read user input from $ttyfd
while IFS= read -r grp; do
  [[ -z "$grp" ]] && continue
  paths=("${(@f)$(print -r -- "$grp" | "$JQ" -r '.paths[]')}")

  print "\n${fg_bold[blue]}Duplicate group:${reset_color}"
  for i in {1..${#paths[@]}}; do
    print "  ${fg_bold[cyan]}$i${reset_color}) ${paths[$i]}"
  done

  # Choose canonical index (force per group; no "all")
  local sel_num=""
  while :; do
    print -n "${fg_bold[yellow]}Choose canonical index${reset_color} [1-${#paths[@]}]: " >&$ttyfd
    read -u $ttyfd sel_num
    [[ "$sel_num" == <-> && $sel_num -ge 1 && $sel_num -le ${#paths[@]} ]] && break
  done

  canonical="${paths[$sel_num]}"
  canon_base=${canonical:t}

  # Rename the others to match the canonical basename
  for p in "${paths[@]}"; do
    [[ "$p" == "$canonical" ]] && continue
    new_path="${p:h}/$canon_base"
    [[ "$p" == "$new_path" ]] && continue

    if [[ -e "$new_path" ]]; then
      print "${fg_bold[red]}Skip (exists)${reset_color}:\n  $new_path"
      continue
    fi

    if (( print_only )); then
      printf 'mv -n -- %q %q\n' "$p" "$new_path"
      continue
    fi

    # Pretty prompt: one-per-line
    print "${fg_bold[yellow]}Rename:${reset_color}"
    print "  ${fg[red]}$p${reset_color}"
    print "  ${fg_bold[yellow]}->${reset_color}"
    print "  ${fg[green]}$new_path${reset_color}"
    print -n "[y]es/[n]o: " >&$ttyfd
    read -k 1 -u $ttyfd ans; print
    case "$ans" in
      y|Y) mv -n -- "$p" "$new_path" ;;
      n|N|'') continue ;;
      *)     continue ;;
    esac
  done
done <<< "$groups_json"
