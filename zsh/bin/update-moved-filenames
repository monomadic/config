#!/usr/bin/env zsh
# czk-rename-renamed-only.zsh
# Usage: czk-rename-renamed-only.zsh [-p|--print-only] DIR1 DIR2 [DIR...]
# Requires: czkawka_cli, jq or jaq

set -euo pipefail
emulate -L zsh
setopt no_nomatch
autoload -U colors && colors

print_only=0
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p|--print-only) print_only=1; shift ;;
    --) shift; break ;;
    -*) print -u2 -- "Unknown option: $1"; exit 2 ;;
    *) break ;;
  esac
done

if (( $# < 2 )); then
  print -u2 "Usage: $0 [-p|--print-only] DIR1 DIR2 [DIR...]"
  exit 2
fi

# jq/jaq
if command -v jaq >/dev/null 2>&1; then JQ=(jaq)
elif command -v jq  >/dev/null 2>&1; then JQ=(jq)
else print -u2 "Need jq or jaq"; exit 1; fi

command -v czkawka_cli >/dev/null 2>&1 || { print -u2 "Need czkawka_cli"; exit 1; }

# Build -d args
dargs=()
for d in "$@"; do dargs+=(-d "$d"); done

# tmp JSON (auto-removed)
tmpjson="$(mktemp -t czkawka_dups.XXXXXX.json)"
cleanup() { rm -f "$tmpjson" 2>/dev/null || true; }
trap cleanup EXIT

# Run czkawka (silence stdout)
czkawka_cli dup "${dargs[@]}" -s size --dry-run --compact-file-to-save "$tmpjson" >/dev/null

# Stream duplicate groups
groups_json="$("$JQ" -c '
  to_entries[]
  | .value as $files
  | select(($files|length) > 1)
  | { paths: ($files | map(.path)) }
' "$tmpjson" || true)"

[[ -z "$groups_json" ]] && { print "${fg_bold[yellow]}No duplicate groups.${reset_color}"; exit 0; }

# Open TTY for prompts even while reading a stream
if [[ -t 0 ]]; then
  exec {ttyfd}<>/dev/tty
else
  print -u2 "Warning: no TTY; use -p for print-only mode."
  ttyfd=0
fi

renamed_groups=0

while IFS= read -r grp; do
  [[ -z "$grp" ]] && continue
  paths=("${(@f)$(print -r -- "$grp" | "$JQ" -r '.paths[]')}")

  # Collect basenames and detect if all equal
  typeset -A seen=()
  for p in "${paths[@]}"; do seen[${p:t}]=1; done
  if (( ${#seen[@]} == 1 )); then
    # All filenames identical → only moved; skip entirely
    continue
  fi

  ((renamed_groups++))
  print "\n${fg_bold[blue]}Select correct filename:${reset_color}"

  # For each possible canonical choice, show only renames for entries whose basename differs
  for i in {1..${#paths[@]}}; do
    canon="${paths[$i]}"
    canon_base=${canon:t}
    print -n "${fg_bold[cyan]}$i${reset_color}) "
    for p in "${paths[@]}"; do
      [[ "$p" == "$canon" ]] && continue
      [[ "${p:t}" == "$canon_base" ]] && continue  # same basename already → no rename
      new_path="${p:h}/$canon_base"
      print "${new_path:t}"
    done
  done

  # Choose canonical index (no "all")
  local sel_num=""
  while :; do
    print -n "${fg_bold[yellow]}Choose canonical index${reset_color} [1-${#paths[@]}]: " >&$ttyfd
    read -u $ttyfd sel_num
    [[ "$sel_num" == <-> && $sel_num -ge 1 && $sel_num -le ${#paths[@]} ]] && break
  done

  canonical="${paths[$sel_num]}"
  canon_base=${canonical:t}

  # Apply renames ONLY where basename differs
  for p in "${paths[@]}"; do
    [[ "$p" == "$canonical" ]] && continue
    [[ "${p:t}" == "$canon_base" ]] && continue
    new_path="${p:h}/$canon_base"

    # Hard error if destination exists
    if [[ -e "$new_path" ]]; then
      print -u2 "${fg_bold[red]}ERROR:${reset_color} destination exists:"
      print -u2 "  $new_path"
      continue
    fi

    if (( print_only )); then
      printf 'mv -n -- %q %q\n' "$p" "$new_path"
      continue
    fi

    # Confirm per-file
    print "${fg_bold[yellow]}Rename:${reset_color}"
    print "  ${fg[red]}$p${reset_color}"
    print "  ${fg_bold[yellow]}->${reset_color}"
    print "  ${fg[green]}$new_path${reset_color}"
    print -n "[y]es/[n]o: " >&$ttyfd
    read -k 1 -u $ttyfd ans; print
    case "$ans" in
      y|Y) mv -n -- "$p" "$new_path" ;;
      n|N|'') continue ;;
      *)     continue ;;
    esac
  done
done <<< "$groups_json"

((renamed_groups == 0)) && print "${fg_bold[green]}No renamed files detected.${reset_color}"
