#!/usr/bin/env zsh
set -euo pipefail

DB="${HOME}/Library/Application Support/VirtualDJ/database.xml"
STEMS_DIR=""          # optional
CLEAR_MISSING=false   # optional

STEM_FLAG=33554432

usage() {
  print -u2 "usage: ${0:t} [--db FILE] [--stems-dir DIR] [--clear-missing]"
  exit 2
}

while (( $# )); do
  case "$1" in
    --db)         DB="$2"; shift 2 ;;
    --stems-dir)  STEMS_DIR="$2"; shift 2 ;;
    --clear-missing) CLEAR_MISSING=true; shift ;;
    -h|--help)    usage ;;
    *) print -u2 "unknown arg: $1"; usage ;;
  esac
done

python3 - <<'PY' "$DB" "$STEMS_DIR" "$STEM_FLAG" "$CLEAR_MISSING"
import os, re, sys

db_path, stems_dir, stem_flag_s, clear_missing_s = sys.argv[1:5]
stem_flag = int(stem_flag_s)
clear_missing = (clear_missing_s.lower() == "true")

with open(db_path, "rb") as f:
    data = f.read()

# Preserve original bytes as much as possible; operate in UTF-8 text.
txt = data.decode("utf-8", errors="strict")

# Optional: pre-index all .vdjstems paths under stems_dir (fast membership tests)
stems_index = set()
if stems_dir:
    for root, _, files in os.walk(stems_dir):
        for fn in files:
            if fn.endswith(".vdjstems"):
                stems_index.add(os.path.join(root, fn))

def has_vdjstems(file_path: str) -> bool:
    # Most common: sidecar next to track
    sidecar = file_path + ".vdjstems"
    if os.path.exists(sidecar):
        return True
    if not stems_dir:
        return False

    # stemsSavedFolder mode: search for basename match anywhere under stems_dir.
    target = os.path.basename(sidecar)
    # Heuristic: accept any unique match; if multiple, prefer those whose parent
    # folder name matches the track's parent folder name.
    candidates = [p for p in stems_index if os.path.basename(p) == target]
    if not candidates:
        return False
    if len(candidates) == 1:
        return True

    track_parent = os.path.basename(os.path.dirname(file_path))
    preferred = [p for p in candidates if os.path.basename(os.path.dirname(p)) == track_parent]
    return bool(preferred) or True  # still treat as found if ambiguous

# Patch only <Song ...> start tags; do not reserialize XML.
song_re = re.compile(r'(<Song\b[^>]*\bFilePath=")([^"]+)("([^>]*)>)', re.IGNORECASE)

changed = 0
seen = 0
ambiguous = 0

def xml_unescape(s: str) -> str:
    return (s.replace("&quot;", '"')
             .replace("&apos;", "'")
             .replace("&lt;", "<")
             .replace("&gt;", ">")
             .replace("&amp;", "&"))

def repl(m: re.Match) -> str:
    global changed, seen, ambiguous
    seen += 1

    prefix, fp_raw, suffix_and_rest, _rest = m.group(1), m.group(2), m.group(3), m.group(4)
    fp = xml_unescape(fp_raw)

    found = has_vdjstems(fp)

    tag = prefix + fp_raw + suffix_and_rest

    # Find existing Flag="N"
    flag_m = re.search(r'\bFlag="(\d+)"', tag)
    if flag_m:
        old = int(flag_m.group(1))
        if found:
            new = old | stem_flag
        else:
            new = (old & ~stem_flag) if clear_missing else old
        if new != old:
            tag = tag[:flag_m.start(1)] + str(new) + tag[flag_m.end(1):]
            changed += 1
        return tag

    # No Flag attr: insert one if found
    if found:
        # insert before the closing '>' of the <Song ...> start tag
        tag = tag[:-1] + f' Flag="{stem_flag}">'
        changed += 1
    return tag

new_txt = song_re.sub(repl, txt)

bak = db_path + ".bak"
out = db_path + ".new"

# Write new file + backup; don't clobber original until both are written
if not os.path.exists(bak):
    with open(bak, "wb") as f:
        f.write(data)

with open(out, "wb") as f:
    f.write(new_txt.encode("utf-8"))

print(f"Songs scanned: {seen}")
print(f"Songs updated: {changed}")
print(f"Wrote: {out}")
print(f"Backup: {bak}")
PY

print -u2 "OK. If that looks right, do:"
print -u2 "  mv -f -- '$DB.new' '$DB'"
