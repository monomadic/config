#!/usr/bin/env bash

usage() {
  echo "Usage: $0 [--match-string STRING]... [--sort SORT_OPTION] [--reverse] [--verbose]" >&2
  echo "Options:" >&2
  echo " --match-string STRING   Only list files where the path contains all the given strings (case-insensitive). Can be used multiple times." >&2
  echo " --sort SORT_OPTION      Sort files by the given option (modified, size, name)" >&2
  echo " --reverse               Reverse the sort order and the final list" >&2
  echo " --verbose               Enable verbose logging" >&2
}

verbose=false

log_verbose() {
  if $verbose; then
    echo "[DEBUG] $1" >&2
  fi
}

match_strings=()
sort_option=""
reverse=false

# Parse command-line arguments
while [ $# -gt 0 ]; do
  case $1 in
  --match-string)
    match_strings+=("$2")
    shift 2
    ;;
  --sort)
    sort_option="$2"
    shift 2
    ;;
  --reverse)
    reverse=true
    shift
    ;;
  --verbose)
    verbose=true
    shift
    ;;
  *)
    usage
    exit 1
    ;;
  esac
done

process_input_fd() {
  local dir="$1"
  log_verbose "Processing input with fd-video in directory: $dir"
  cd "$dir" || {
    log_verbose "Failed to change to directory: $dir"
    return 1
  }

  # Build fd-video command arguments
  fd_video_cmd=(fd-video -t f --full-path)
  log_verbose "Executing in $dir: ${fd_video_cmd[*]}"

  # Execute fd-video and filter results using grep for each match string
  "${fd_video_cmd[@]}" | {
    local result
    result=$(cat)
    for str in "${match_strings[@]}"; do
      result=$(echo "$result" | grep -F -i -- "$str")
    done
    echo "$result"
  } | {
    if [ -n "$sort_option" ]; then
      case "$sort_option" in
      modified)
        while IFS= read -r file; do
          stat -f "%m %N" "$file"
        done | sort -n | cut -d' ' -f2-
        ;;
      size)
        while IFS= read -r file; do
          stat -f "%z %N" "$file"
        done | sort -n | cut -d' ' -f2-
        ;;
      name)
        sort
        ;;
      *)
        cat
        ;;
      esac
    else
      cat
    fi
  } | while IFS= read -r file; do
    printf '%s/%s\n' "$dir" "$file"
  done
}

directories=$(ls-media-paths)
log_verbose "Directories to search: $directories"
if [ -z "$directories" ]; then
  echo "Error: No directories found from ls-media-paths" >&2
  exit 1
fi

# Temporary file to store all results
temp_file=$(mktemp)
for dir in $directories; do
  log_verbose "Searching directory: $dir"
  if [ ! -d "$dir" ]; then
    log_verbose "Skipping non-existent or non-directory: $dir"
    continue
  fi
  if [ ! -r "$dir" ]; then
    log_verbose "Cannot read directory $dir (permission denied)"
    continue
  fi
  process_input_fd "$dir" >>"$temp_file"
done

# Reverse the entire list if --reverse option is used
if $reverse; then
  tac "$temp_file"
else
  cat "$temp_file"
fi
rm "$temp_file"
log_verbose "Script execution completed"
