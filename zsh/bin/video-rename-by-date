#!/usr/bin/env zsh
# Timestamp + Video Info Renamer
# Dependencies:
#   - ffprobe (ffmpeg)
#   - exiftool (optional, for "date taken"; falls back to filesystem birth time)

set -euo pipefail

DRY_RUN=false
USE_COLOR=false

# NerdFonts icons
ICON_VIDEO="󰎈"
ICON_OK="✔"
ICON_WARN=""

# Color handling (disabled by default)
RESET=""; GREEN=""; YELLOW=""; CYAN=""

enable_color() {
  RESET=$'\e[0m'
  GREEN=$'\e[32m'
  YELLOW=$'\e[33m'
  CYAN=$'\e[36m'
  USE_COLOR=true
}

usage() {
  cat >&2 <<EOF
Usage: ${0:t} [OPTIONS] video_file...

Renames videos to:
  YYYY-MM-DD-HH-MM Clean Name {1080p 60fps 4min 20mbps}.ext

Timestamp priority:
  1) Metadata (DateTimeOriginal / CreateDate / MediaCreateDate via exiftool)
  2) Filesystem creation time (stat birth time)

Options:
  --dry-run    Show what would be done without renaming
  --color      Enable ANSI colors in output
  -h, --help   Show this help
EOF
  exit 0
}

# --- Parse options
while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run) DRY_RUN=true; shift ;;
    --color)   enable_color; shift ;;
    -h|--help) usage ;;
    -*)
      print -r -- "${YELLOW}${ICON_WARN} Unknown option: $1${RESET}"
      exit 1
      ;;
    *) break ;;
  esac
done

(( $# >= 1 )) || usage

# Ensure ffprobe exists
if ! command -v ffprobe &>/dev/null; then
  print -r -- "${YELLOW}${ICON_WARN} ffprobe is required but not installed.${RESET}"
  exit 1
fi

# exiftool is optional; we check later before using

# --- Helpers ---

# Strip ALL {...} blocks, leading timestamp, and known #tags from the "title" part
clean_name() {
  local name="$1"

  # strip leading YYYY-MM-DD-HH-MM plus optional space/dash/underscore
  name="$(printf '%s' "$name" | sed -E 's/^[0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{2}-[0-9]{2}[[:space:]_-]*//')"

  # remove every {...} block (non-nested)
  name="$(printf '%s' "$name" | sed -E 's/\{[^}]*\}//g')"

  # remove specific #tags
  local tags=(1080p 1080 720p 4k 60fps 30fps 25fps)
  for t in $tags; do
    name="${name//\#$t/}"
  done

  # remove trailing " s01"
  name="$(printf '%s' "$name" | sed -E 's/[[:space:]]s01$//I')"

  # collapse & trim spaces
  name="${name//  / }"; name="${name//  / }"   # twice to be safe
  name="${name## }"; name="${name%% }"
  print -r -- "$name"
}

# Map smaller dimension to a resolution label
get_resolution_label() {
  local d=${1:-0}
  if   (( d <= 480  )); then print -r -- "480p"
  elif (( d <= 720  )); then print -r -- "720p"
  elif (( d <= 1080 )); then print -r -- "1080p"
  elif (( d <= 1440 )); then print -r -- "1440p"
  elif (( d <= 2160 )); then print -r -- "2160p"
  else                      print -r -- "${d}p"
  fi
}

# Get timestamp (YYYY-MM-DD-HH-MM) from metadata or filesystem
get_timestamp() {
  local f="$1"
  local ts=""

  # 1) Metadata via exiftool (if installed)
  if command -v exiftool >/dev/null 2>&1; then
    ts=$(exiftool -s -s -s -d '%Y-%m-%d-%H-%M' \
          -DateTimeOriginal -CreateDate -MediaCreateDate -- "$f" 2>/dev/null | head -n1 || true)
  fi

  # 2) Fallback: filesystem creation time (birthtime) via stat on macOS
  if [[ -z $ts ]]; then
    local epoch=""
    if epoch=$(stat -f '%B' -- "$f" 2>/dev/null); then
      ts=$(date -r "$epoch" '+%Y-%m-%d-%H-%M')
    fi
  fi

  print -r -- "$ts"
}

# Convert duration seconds -> human string: "30sec", "4min", "1.5hr"
format_duration() {
  local secs="$1"
  local out="unknown"

  if (( secs < 60 )); then
    out="${secs}sec"
  elif (( secs < 3600 )); then
    # nearest minute
    local mins=$(( (secs + 30) / 60 ))
    out="${mins}min"
  else
    # hours with one decimal
    out="$(awk -v s="$secs" 'BEGIN{printf("%.1fhr", s/3600)}')"
  fi

  print -r -- "$out"
}

process_video() {
  local file="$1"
  local filename="${file:t}"
  local dirname="${file:h}"
  local extension="${filename:e}"

  # normalize extension: m4v -> mp4, then lowercase
  [[ "${extension:l}" == "m4v" ]] && extension="mp4" || extension="${extension:l}"

  local raw_base="${filename:r}"

  # Get timestamp
  local ts
  ts="$(get_timestamp "$file")"
  if [[ -z "$ts" ]]; then
    print -r -- "${YELLOW}${ICON_WARN} Could not determine timestamp: $file${RESET}"
    return
  fi

  # Clean the "title" portion from the original name
  local clean_title
  clean_title="$(clean_name "$raw_base")"

  # Probe video info (width/height/fps/bitrate)
  local video_info
  if ! video_info=$(ffprobe -v error -select_streams v:0 \
        -show_entries stream=width,height,r_frame_rate,bit_rate \
        -of csv=p=0:s=, -- "$file" 2>/dev/null); then
    print -r -- "${YELLOW}${ICON_WARN} Could not read video info: $file${RESET}"
    return
  fi

  local width height frame_rate bit_rate
  width=$(   print -r -- "$video_info" | cut -d, -f1)
  height=$(  print -r -- "$video_info" | cut -d, -f2)
  frame_rate=$(print -r -- "$video_info" | cut -d, -f3)
  bit_rate=$( print -r -- "$video_info" | cut -d, -f4)

  # fps -> nearest integer (keeps existing ints)
  if [[ $frame_rate == */* ]]; then
    local num=${frame_rate%%/*}
    local denom=${frame_rate##*/}
    if (( denom > 0 )); then
      frame_rate=$(( (num + denom/2) / denom ))
    else
      frame_rate=0
    fi
  fi

  # Resolution from smaller dimension (handles portrait)
  local smaller_dim=$(( width < height ? width : height ))
  local resolution; resolution="$(get_resolution_label "$smaller_dim")"

  # Duration: separate ffprobe call (seconds as float)
  local duration_raw duration_str="unknown"
  if duration_raw=$(ffprobe -v error -show_entries format=duration \
        -of default=noprint_wrappers=1:nokey=1 -- "$file" 2>/dev/null); then
    if [[ -n "$duration_raw" && "$duration_raw" != "N/A" ]]; then
      # round to nearest second
      local secs
      secs=$(awk -v d="$duration_raw" 'BEGIN{printf("%d", int(d+0.5))}')
      duration_str="$(format_duration "$secs")"
    fi
  fi

  # Mbps as integer, rounded
  local mbps="unknown"
  if [[ -n "${bit_rate:-}" && "$bit_rate" != "N/A" ]]; then
    mbps="$(awk -v b="$bit_rate" 'BEGIN{printf("%dmbps", int(b/1000000+0.5))}')"
  fi

  # Build new base name: timestamp + optional cleaned title
  local new_base="$ts"
  [[ -n "$clean_title" ]] && new_base+=" $clean_title"

  # Collect meta fields dynamically (avoid trailing "unknown" spam if you ever change logic)
  local -a meta_fields
  meta_fields+=("$resolution")
  meta_fields+=("${frame_rate}fps")
  meta_fields+=("$duration_str")
  meta_fields+=("$mbps")

  local meta_block=" {${(j: :)meta_fields}}"

  local new_name="${new_base}${meta_block}.${extension}"
  local target="${dirname}/${new_name}"

  # Collision handling: add -01, -02, ... *before* the metadata block
  if [[ -e "$target" && "$target" != "$file" ]]; then
    local i=1 suffix
    while :; do
      suffix=$(printf '%02d' "$i")
      new_name="${new_base}-${suffix}${meta_block}.${extension}"
      target="${dirname}/${new_name}"
      [[ -e "$target" ]] || break
      (( i++ ))
    done
  fi

  # Idempotency: if already has that exact name, skip
  if [[ "$target" == "$file" ]]; then
    print -r -- "${CYAN}${ICON_VIDEO} skip (already named): ${filename}${RESET}"
    return
  fi

  if $DRY_RUN; then
    print -r -- "${CYAN}${ICON_VIDEO} $filename -> ${new_name}${RESET}"
  else
    mv -- "$file" "$target"
    print -r -- "${GREEN}${ICON_OK} $filename -> ${new_name}${RESET}"
  fi
}

# --- Process args ---
for file in "$@"; do
  if [[ -f "$file" ]]; then
    case "${file:l}" in
      *.mp4|*.mov|*.avi|*.mkv|*.wmv|*.flv|*.webm|*.m4v)
        process_video "$file"
        ;;
      *)
        print -r -- "${YELLOW}${ICON_WARN} skip (not a supported video): $file${RESET}"
        ;;
    esac
  else
    print -r -- "${YELLOW}${ICON_WARN} skip (not a file): $file${RESET}"
  fi
done
