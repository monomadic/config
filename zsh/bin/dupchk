#!/usr/bin/env zsh
# dupsize-simple.zsh — duplicate-size files at exact depth 1
# deps: fd, (fzf for -i), /usr/bin/stat, trash (optional), mediainfo (for preview)

set -o pipefail
set -o noclobber
set -o nounset

STAT="/usr/bin/stat"
command -v fd >/dev/null 2>&1 || { print -ru2 -- "fd not found"; exit 127; }
[[ -x $STAT ]] || { print -ru2 -- "BSD stat missing"; exit 127; }

use_group=false
use_interactive=false
srcdir="."

while getopts "gi" opt; do
  [[ $opt == g ]] && use_group=true
  [[ $opt == i ]] && use_interactive=true
done
shift $((OPTIND-1))
[[ $# -gt 0 ]] && srcdir="$1"
[[ -d $srcdir ]] || { print -ru2 -- "Not a directory: $srcdir"; exit 1; }
if $use_interactive; then
  command -v fzf >/dev/null 2>&1 || { print -ru2 -- "fzf required for -i"; exit 127; }
fi

# --- colors (zsh %F) -----------------------------------------------------------
autoload -Uz colors && colors
c() { print -P -- "%F{$1}$2%f"; }
hdr() { c cyan "$1"; }
fnc() { c green "$1"; }
mut() { c 8 "$1"; }  # dim

# --- temp dir (avoid noclobber issues) ----------------------------------------
tmpdir="$(mktemp -d -t dupsize.XXXXXXXX)" || { print -ru2 -- "mktemp failed"; exit 1; }
trap 'rm -rf -- "$tmpdir"' EXIT
tmp_table="$tmpdir/table.tsv"

# Build table: "<size>\t<path>"
fd . "$srcdir" --exact-depth 1 -t f -0 \
| xargs -0 -I{} "$STAT" -f $'%z\t%N' -- "{}" 2>/dev/null \
| LC_ALL=C sort -n > "$tmp_table"

# Sizes with count > 1
dup_sizes="$(awk -F '\t' '{c[$1]++} END{for (s in c) if (c[s]>1) print s}' "$tmp_table" | LC_ALL=C sort -n)"

[[ -z $dup_sizes ]] && { c 8 "No duplicate-size files found at depth 1 in: $srcdir"; exit 0; }

# List files for a size (strip surrounding quotes that %N may add)
files_for_size() {
  local sz="$1"
  awk -F '\t' -v s="$sz" '
    $1==s {
      name=$2; gsub(/^"|"$/, "", name);
      print name
    }
  ' "$tmp_table"
}

safe_trash() {
  local f="$1"
  [[ -n $f ]] || return 0
  local p="$f"
  [[ ${p##*/} == -* ]] && p="./$p"   # avoid option parsing

  if command -v trash >/dev/null 2>&1; then
    trash "$p"
  else
    local td="$HOME/.Trash"; mkdir -p -- "$td"
    local base="${f:t}" dst="$td/$base"
    if [[ -e $dst ]]; then
      local ts; ts=$(date +%Y%m%d-%H%M%S); local n=1
      while [[ -e "$td/${base} (${ts}-${n})" ]]; do ((n++)); done
      dst="$td/${base} (${ts}-${n})"
    fi
    mv -n -- "$f" "$dst"
  fi
}

if $use_interactive; then
  print -- "Duplicate-size groups (interactive)…"
  # preview at bottom, prefer mediainfo, fallback to file/ls
  local preview_cmd
  if command -v mediainfo >/dev/null 2>&1; then
    preview_cmd='mediainfo "{}" || file -b "{}" || /bin/ls -l "{}"'
  else
    preview_cmd='file -b "{}" || /bin/ls -l "{}"'
  fi

  while IFS= read -r sz; do
    print
    print -- "$(hdr "# $sz bytes")"
    list="$(files_for_size "$sz")"
    # show plain list to fzf; colorization is for non-interactive mode
    print -- "$list"
    keep="$(print -- "$list" | fzf \
      --prompt="keep> " \
      --header="Select ONE to keep (size: $sz bytes)" \
      --no-multi \
      --ansi \
      --preview "$preview_cmd" \
      --preview-window=down:60%:wrap,border-top \
      --height=90% \
      --border \
      || true)"
    [[ -z $keep ]] && { mut "(skipped)"; continue; }
    while IFS= read -r f; do
      [[ -z $f || $f == "$keep" ]] && continue
      safe_trash "$f"
    done <<< "$list"
    print -- "$(fnc "kept: $keep")"
  done <<< "$dup_sizes"
  exit 0
fi

# --- colored non-interactive output -------------------------------------------
if $use_group; then
  while IFS= read -r sz; do
    print
    print -- "$(hdr "# $sz bytes")"
    files_for_size "$sz" | while IFS= read -r f; do
      [[ -n $f ]] && print -- "  $(fnc "$f")"
    done
  done <<< "$dup_sizes"
else
  # flat: just all dup-size files, colored
  while IFS= read -r sz; do
    files_for_size "$sz" | while IFS= read -r f; do
      [[ -n $f ]] && print -- "$(fnc "$f")"
    done
  done <<< "$dup_sizes"
fi
