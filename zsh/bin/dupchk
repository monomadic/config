#!/usr/bin/env zsh
# dupsize-simple.zsh — duplicate-size files at exact depth 1
# deps: fd, (fzf for -i), /usr/bin/stat, trash (optional)

set -o pipefail
set -o noclobber
set -o nounset

STAT="/usr/bin/stat"
command -v fd >/dev/null 2>&1 || { print -ru2 -- "fd not found"; exit 127; }
[[ -x $STAT ]] || { print -ru2 -- "BSD stat missing"; exit 127; }

use_group=false
use_interactive=false
srcdir="."

while getopts "gi" opt; do
  [[ $opt == g ]] && use_group=true
  [[ $opt == i ]] && use_interactive=true
done
shift $((OPTIND-1))
[[ $# -gt 0 ]] && srcdir="$1"
[[ -d $srcdir ]] || { print -ru2 -- "Not a directory: $srcdir"; exit 1; }
if $use_interactive; then
  command -v fzf >/dev/null 2>&1 || { print -ru2 -- "fzf required for -i"; exit 127; }
fi

# temp dir (avoids noclobber issue)
tmpdir="$(mktemp -d -t dupsize.XXXXXXXX)" || { print -ru2 -- "mktemp failed"; exit 1; }
trap 'rm -rf -- "$tmpdir"' EXIT
tmp_table="$tmpdir/table.tsv"

# Build table: "<size>\t<path>"
# NOTE: BSD stat %N may add quotes; we'll strip later.
fd . "$srcdir" --exact-depth 1 -t f -0 \
| xargs -0 -I{} "$STAT" -f $'%z\t%N' -- "{}" 2>/dev/null \
| LC_ALL=C sort -n > "$tmp_table"

# Sizes with count > 1
dup_sizes="$(awk -F '\t' '{c[$1]++} END{for (s in c) if (c[s]>1) print s}' "$tmp_table" | LC_ALL=C sort -n)"

[[ -z $dup_sizes ]] && { print -- "No duplicate-size files found at depth 1 in: $srcdir"; exit 0; }

# List files for a size (strip surrounding quotes)
files_for_size() {
  local sz="$1"
  awk -F '\t' -v s="$sz" '
    $1==s {
      name=$2; gsub(/^"|"$/, "", name);
      print name
    }
  ' "$tmp_table"
}

safe_trash() {
  local f="$1"
  [[ -n $f ]] || return 0

  # normalize path to avoid option parsing for dash-prefixed names
  local p="$f"
  [[ ${p##*/} == -* ]] && p="./$p"

  if command -v trash >/dev/null 2>&1; then
    # Node 'trash' doesn’t support the GNU-style “--” separator; don’t pass it.
    trash "$p"
  else
    # Fallback: move to ~/.Trash with uniquified name
    local td="$HOME/.Trash"; mkdir -p -- "$td"
    local base="${f:t}" dst="$td/$base"
    if [[ -e $dst ]]; then
      local ts; ts=$(date +%Y%m%d-%H%M%S); local n=1
      while [[ -e "$td/${base} (${ts}-${n})" ]]; do ((n++)); done
      dst="$td/${base} (${ts}-${n})"
    fi
    mv -n -- "$f" "$dst"
  fi
}

if $use_interactive; then
  print -- "Duplicate-size groups (interactive)…"
  while IFS= read -r sz; do
    print; print -- "# $sz bytes"
    list="$(files_for_size "$sz")"
    print -- "$list"
    keep="$(print -- "$list" | fzf --prompt="keep> " --header="Select ONE to keep (size: $sz bytes)" --no-multi --preview 'ls -l "{}"' --preview-window=right:60%:wrap || true)"
    [[ -z $keep ]] && { print -- "(skipped)"; continue; }
    while IFS= read -r f; do
      [[ -z $f || $f == "$keep" ]] && continue
      safe_trash "$f"
    done <<< "$list"
    print -- "kept: $keep"
  done <<< "$dup_sizes"
  exit 0
fi

if $use_group; then
  while IFS= read -r sz; do
    print; print -- "# $sz bytes"
    files_for_size "$sz"
  done <<< "$dup_sizes"
else
  while IFS= read -r sz; do
    files_for_size "$sz"
  done <<< "$dup_sizes"
fi
