#!/bin/zsh
set +o monitor

handle_directory_selection() {
  local pipe=$(mktemp -u)
  mkfifo "$pipe" || return 1

  cleanup() {
    local exit_code=$?
    # Kill only the specific background process if it exists
    [[ -n "$input_pid" ]] && kill $input_pid 2>/dev/null
    wait 2>/dev/null || true
    rm -f "$pipe"
    trap - INT TERM EXIT HUP
    return $exit_code
  }
  trap cleanup INT TERM EXIT HUP

  # Read from stdin to pipe in background, but close when stdin closes
  (
    cat >"$pipe"
    kill -PIPE $$ 2>/dev/null
  ) &
  local input_pid=$!

  local dir
  dir=$(fzf --ansi \
    --preview 'tree -C {} 2>/dev/null || lsd --icon always --long --depth 1 --ignore-config --group-directories-first --color always {}' \
    --bind 'ctrl-d:preview-page-down,ctrl-u:preview-page-up' \
    --bind 'ctrl-/:toggle-preview' \
    --bind 'alt-p:toggle-preview' \
    --no-info \
    --height=50% \
    --reverse \
    --prompt="‚ùØ " <"$pipe")
  local ret=$?

  # Cleanup will handle killing the background process
  if [[ $ret -eq 0 && -n "$dir" ]]; then
    printf '%s\n' "$dir"
  fi
  return $ret
}

handle_directory_selection "$@"
