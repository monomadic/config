#!/usr/bin/env zsh
# edit-bin: pick executable scripts from ~/.zsh/bin and ~/.bin via fzf; Enter opens in $EDITOR

emulate -L zsh -o pipefail
setopt err_return no_nomatch

# Resolve editor (supports things like "code -w")
local -a editor
editor=(${=VISUAL:-${=EDITOR:-nvim}})

# Candidate dirs
local -a dirs
for d in "$HOME/.zsh/bin" "$HOME/.bin"; do
  [[ -d $d ]] && dirs+="$d"
done
(( ${#dirs} )) || { print -u2 "No candidate dirs found."; exit 1 }

# Gather only executables that are text files (avoid ELF/Mach-O binaries)
local -a files
files=("${(@f)$(fd --hidden --follow --type x . -- "${dirs[@]}" \
  -x sh -c 'file -b --mime-type "$1"' sh {} | \
  paste -d' ' - <(fd --hidden --follow --type x . -- "${dirs[@]}") | \
  awk '$1 ~ /^text\//' | cut -d' ' -f2- )}")

(( ${#files} )) || { print -u2 "No executable scripts found."; exit 1 }

# Preview: bat if present, else head
local preview
if (( $+commands[bat] )); then
  preview='bat --style=plain --paging=never --line-range=:200 --color=always -- "{}"'
else
  preview='head -n 200 -- "{}"'
fi

# FZF picker: display just filename, but pass full path
local choice
choice=$(printf '%s\n' "${files[@]}" | awk '{print $NF}' | fzf \
  --prompt='scripts> ' \
  --height=80% \
  --ansi \
  --preview="$preview" \
  --preview-window=right:60%:wrap \
  --select-1 --exit-0 \
  --bind 'enter:accept')

[[ -n $choice ]] || exit 0

# Map chosen basename back to full path
local filepath
filepath=$(printf '%s\n' "${files[@]}" | grep "/$choice\$" | head -n1)

exec "${editor[@]}" -- "$filepath"
